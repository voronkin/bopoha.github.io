---
title: "База знаний"
excerpt: "База знаний"
sitemap: true
layout: single
author_profile: false
permalink: /kb.html
---

Здесь находятся ссылки и краткое описание фреймфорков, инструментов

# JavaScript

## Инструменты

- [Fake Online REST API for Testing and Prototyping](https://jsonplaceholder.typicode.com/)

## npm

Node Package Manager

`npm init` - инициализация нового проекта, создание package.json

## Библиотеки

- [Promise based HTTP-client for the browser and node.js](https://github.com/axios/axios)

### Node.JS

### Redux

#### Введение

Redux - предсказуемый контейнер состояний для JS. Замечательно сочетается с React и другими библиотеками.
Размер библиотеки - 2 Кб + большая экосистема дополнений.
Установка - через npm или UMD-пакет (через script), также имеется Redux Toolkit (RTK). RTK официально рекомендуется для использования.

Принцип работы вкратце: полное состояние приложения сохраняется в дереве объектов внутри единственного хранилища (store). Единственный способ изменить состояние - "испустить, излучить" (emit) действие (action), объект, описывающий, что происходит. Для указания того, как действие трансформируют дерево состояния, пишется чистая функция - reducer.
`(state, action) => state`

Вместо изменения состояния напрямую, вы указываете изменения (mutations), которые вы хотите внесте с помощью простых объектов (actions).

В типичном Redux-приложении обычно одно хранилище с единственной корневой reducer-функцией. По мере того, как ваше приложение растёт, вы разбиваете корневую функцию на маленькие функции, независимо действующие на различные части дерева состояния. Аналогия с архитектурой React - один корневой компонент, состоящий из множества мелких компонентов.
Такая архитектура может показаться излишне громоздкой для простых приложений, но сложность такого паттерна окупается в процессе масштабирования и усложнения приложения. Особенность архитектуры также позволяет воспользоваться мощными инструментами разработки, так как становится возможным отследить каждое изменение и каждое действие, которое к этому изменению привело. Можно записать всю пользовательскую сессию и пошагово воспроизвести каждое действие.

#### Мотивация

По мере того, как требования для одностраничых приложений, написанных на JavaScript (JavaScript SPA) становятся всё более сложными, модель данных приложения (состояние), которой наш код управляет, расширяется. Состояние, которым надо управлять, может включать в себя ответы сервера и закэшированные данные, а также данные в локальном хранилище, которые еще не сохранены на сервере. Объем состояния элементов пользовательского интерфейса тоже увеличивается и усложняется, например поддержка активных routes, вкладки, спиннеры, пагинация и т.д.

Управление такой постоянно изменяющейся моделью данных - сложное. Если модель может обновить другую модель, затем представление может обновить модель, что , в свою очередь, приводит к обновлению другой модели и обновлению другого представления. В какой-то момент вы больше не понимаете что происходит в вашем приложении, так как вы теряете контроль над тем, когда, почему и что происходит с моделью данных. Когда система не прозрачна и недетерминированна, очень сложно воспроизвести при отладке ошибки или добавить новый функционал.

Всё вышенаписанное еще цветочки - а вот теперь ягодки: рассмотрим новые требования, которые постепенно становятся стандартом в фронт-энд разработке. Мы, как разаботчики, рассчитываем на управление оптимистичными обновлениями, рендерингом на стороне сервера, выборкой данных до пересылки по маршрутам и так далее. Мы обнаруживаем себя пытающимися управлять сложностью, с которой нам ещё не приходилось сталкиваться и мы неизбежно задаёмся вопросом:
**пришло время сдаться?**. Ответ - нет, не пришло.

Такая сложность управления происходит из-за того, что мы смешиваем две концепции, которые крайне тяжело сочетаются: **изменения** и **асинхронность**. Смесь этих двух концепций - это смесь "Ментос" и "Кока Колы". Оба подхода прекрасно работают по отдельности, но при совместном использовании достигается обратный эффект. Библиотеки типа React пытаются решить данную проблему в слое представления путём удаления асинхронности и прямого взаимодействия с DOM.
Управление состоянием модели данных остаётся на ваше усмотрение. И тут в дело вступает Redux.

Продолжая дело Flux, CQRS и Event Sourcing, Redux пытается сделать изменения состояния модели данных **предсказуемым** путём точного разграничения того, как и когда обновления модели могут происходить. Эти разграничения отражены в Трёх Принципах Redux.

#### Три Принципа Redux

##### Единственный источник правды

**Глобальное состояние модели данных вашего приложения хранится в дереве объектов внутри одного единственного хранилища.**

Это облегчает создание универсальных приложений, так как модель данных может быть сериализовано и восстановлено на клиенте без дополнительных доработок и нового кода. Единое дерево с моделью данных также облегчает отладку приложения. Некоторая функциональность (Undo/Redo, например), которую было традиционно сложно реализовать, теперь реализуется тривиально, если вся модель данных находится в едином дереве.

##### Состояние модели - только для чтения

**Единственный способ изменить - выпустить действие, объект, описывающий что происходит**

Это даёт гарантию, что ни представления, ни сетевые коллбэки не внесут изменения в модель данных напрямую. Вместо этого они выражают намерения изменить модель данных. Из-за того, что все изменения централизованы и происходят по очереди в чётком порядке, не возникает больше race conditions. Так как действия - просто чистые объекты, они могут быть записаны в лог-файлы, сериализованы, сохранены в базу данных и позже воспроизведены в целях отладки или тестирования.

##### Изменения вносятся чистыми функциями

**Для указания ,как именно дерево объектов будет изменено действиями, вы пишете чистые функции - reducers**

Reducers - это просто чистые функции, которые получают предыдущее состояние модели данных и действие, а затем возвращают новое ,следующее состояние. Самое важное здесь - возврат нового состояние вместо изменения предыдущего. Можно начать с одной единственной функции и затем, по мере роста вашего приложения, разбить функцию на несколько меньших, отвечающих за конкретные части дерева объектов.

#### Предшественники

(НЕДОПИСАНО)
У Redux смешанное наследие. Некоторые архитектурные решения схожи с распространёнными паттернами и технологиями, но
